// Created by Microsoft (R) C/C++ Compiler Version 15.00.21022.08 (42d6e52b).
//
// c:\users\gameover\code\videoinput\videoinputsrcanddemos\vc2008-videoinputdemowithsrc\debug\qedit.tli
//
// Wrapper implementations for Win32 type library 78530B68-61F9-11D2-8CAD-00A024580902
// compiler-generated file created 07/14/11 at 17:38:47 - DO NOT EDIT!

#pragma once

//
// interface IResize wrapper method implementations
//

inline HRESULT IResize::get_Size ( int * piHeight, int * piWidth, long * pFlag ) {
    HRESULT _hr = raw_get_Size(piHeight, piWidth, pFlag);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResize::get_InputSize ( int * piHeight, int * piWidth ) {
    HRESULT _hr = raw_get_InputSize(piHeight, piWidth);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResize::put_Size ( int Height, int Width, long Flag ) {
    HRESULT _hr = raw_put_Size(Height, Width, Flag);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResize::get_MediaType ( struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_get_MediaType(pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IResize::put_MediaType ( struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_put_MediaType(pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPropertySetter wrapper method implementations
//

inline HRESULT IPropertySetter::LoadXML ( IUnknown * pxml ) {
    HRESULT _hr = raw_LoadXML(pxml);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::PrintXML ( unsigned char * pszXML, int cbXML, int * pcbPrinted, int indent ) {
    HRESULT _hr = raw_PrintXML(pszXML, cbXML, pcbPrinted, indent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::CloneProps ( struct IPropertySetter * * ppSetter, __int64 rtStart, __int64 rtStop ) {
    HRESULT _hr = raw_CloneProps(ppSetter, rtStart, rtStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::AddProp ( DEXTER_PARAM Param, DEXTER_VALUE * paValue ) {
    HRESULT _hr = raw_AddProp(Param, paValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::GetProps ( long * pcParams, DEXTER_PARAM * * paParam, DEXTER_VALUE * * paValue ) {
    HRESULT _hr = raw_GetProps(pcParams, paParam, paValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::FreeProps ( long cParams, DEXTER_PARAM * paParam, DEXTER_VALUE * paValue ) {
    HRESULT _hr = raw_FreeProps(cParams, paParam, paValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::ClearProps ( ) {
    HRESULT _hr = raw_ClearProps();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::SaveToBlob ( long * pcSize, unsigned char * * ppb ) {
    HRESULT _hr = raw_SaveToBlob(pcSize, ppb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::LoadFromBlob ( long cSize, unsigned char * pb ) {
    HRESULT _hr = raw_LoadFromBlob(cSize, pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::SetProps ( IUnknown * pTarget, __int64 rtNow ) {
    HRESULT _hr = raw_SetProps(pTarget, rtNow);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPropertySetter::PrintXMLW ( unsigned short * pszXML, int cchXML, int * pcchPrinted, int indent ) {
    HRESULT _hr = raw_PrintXMLW(pszXML, cchXML, pcchPrinted, indent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMediaLocator wrapper method implementations
//

inline HRESULT IMediaLocator::FindMediaFile ( _bstr_t Input, _bstr_t FilterString, BSTR * pOutput, long Flags ) {
    HRESULT _hr = raw_FindMediaFile(Input, FilterString, pOutput, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaLocator::AddFoundLocation ( _bstr_t DirectoryName ) {
    HRESULT _hr = raw_AddFoundLocation(DirectoryName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMErrorLog wrapper method implementations
//

inline HRESULT IAMErrorLog::LogError ( long Severity, _bstr_t pErrorString, long ErrorCode, long hresult, VARIANT * pExtraInfo ) {
    HRESULT _hr = raw_LogError(Severity, pErrorString, ErrorCode, hresult, pExtraInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMSetErrorLog wrapper method implementations
//

inline IAMErrorLogPtr IAMSetErrorLog::GetErrorLog ( ) {
    struct IAMErrorLog * _result = 0;
    HRESULT _hr = get_ErrorLog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAMErrorLogPtr(_result, false);
}

inline void IAMSetErrorLog::PutErrorLog ( struct IAMErrorLog * pVal ) {
    HRESULT _hr = put_ErrorLog(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAMTimelineSplittable wrapper method implementations
//

inline HRESULT IAMTimelineSplittable::SplitAt ( __int64 Time ) {
    HRESULT _hr = raw_SplitAt(Time);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSplittable::SplitAt2 ( double Time ) {
    HRESULT _hr = raw_SplitAt2(Time);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineVirtualTrack wrapper method implementations
//

inline HRESULT IAMTimelineVirtualTrack::TrackGetPriority ( long * pPriority ) {
    HRESULT _hr = raw_TrackGetPriority(pPriority);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineVirtualTrack::SetTrackDirty ( ) {
    HRESULT _hr = raw_SetTrackDirty();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineTrans wrapper method implementations
//

inline HRESULT IAMTimelineTrans::GetCutPoint ( __int64 * pTLTime ) {
    HRESULT _hr = raw_GetCutPoint(pTLTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::GetCutPoint2 ( double * pTLTime ) {
    HRESULT _hr = raw_GetCutPoint2(pTLTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::SetCutPoint ( __int64 TLTime ) {
    HRESULT _hr = raw_SetCutPoint(TLTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::SetCutPoint2 ( double TLTime ) {
    HRESULT _hr = raw_SetCutPoint2(TLTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::GetSwapInputs ( long * pVal ) {
    HRESULT _hr = raw_GetSwapInputs(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::SetSwapInputs ( long pVal ) {
    HRESULT _hr = raw_SetSwapInputs(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::GetCutsOnly ( long * pVal ) {
    HRESULT _hr = raw_GetCutsOnly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrans::SetCutsOnly ( long pVal ) {
    HRESULT _hr = raw_SetCutsOnly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineEffect wrapper method implementations
//

inline HRESULT IAMTimelineEffect::EffectGetPriority ( long * pVal ) {
    HRESULT _hr = raw_EffectGetPriority(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IReferenceClock wrapper method implementations
//

inline HRESULT IReferenceClock::GetTime ( __int64 * pTime ) {
    HRESULT _hr = raw_GetTime(pTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IReferenceClock::AdviseTime ( __int64 baseTime, __int64 streamTime, ULONG_PTR hEvent, ULONG_PTR * pdwAdviseCookie ) {
    HRESULT _hr = raw_AdviseTime(baseTime, streamTime, hEvent, pdwAdviseCookie);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IReferenceClock::AdvisePeriodic ( __int64 startTime, __int64 periodTime, ULONG_PTR hSemaphore, ULONG_PTR * pdwAdviseCookie ) {
    HRESULT _hr = raw_AdvisePeriodic(startTime, periodTime, hSemaphore, pdwAdviseCookie);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IReferenceClock::Unadvise ( ULONG_PTR dwAdviseCookie ) {
    HRESULT _hr = raw_Unadvise(dwAdviseCookie);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMediaFilter wrapper method implementations
//

inline HRESULT IMediaFilter::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaFilter::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaFilter::Run ( __int64 tStart ) {
    HRESULT _hr = raw_Run(tStart);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaFilter::GetState ( unsigned long dwMilliSecsTimeout, enum _FilterState * State ) {
    HRESULT _hr = raw_GetState(dwMilliSecsTimeout, State);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaFilter::SetSyncSource ( struct IReferenceClock * pClock ) {
    HRESULT _hr = raw_SetSyncSource(pClock);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaFilter::GetSyncSource ( struct IReferenceClock * * pClock ) {
    HRESULT _hr = raw_GetSyncSource(pClock);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEnumMediaTypes wrapper method implementations
//

inline HRESULT IEnumMediaTypes::Next ( unsigned long cMediaTypes, struct _AMMediaType * * ppMediaTypes, unsigned long * pcFetched ) {
    HRESULT _hr = raw_Next(cMediaTypes, ppMediaTypes, pcFetched);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumMediaTypes::Skip ( unsigned long cMediaTypes ) {
    HRESULT _hr = raw_Skip(cMediaTypes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumMediaTypes::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumMediaTypes::Clone ( struct IEnumMediaTypes * * ppEnum ) {
    HRESULT _hr = raw_Clone(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IRenderEngine2 wrapper method implementations
//

inline HRESULT IRenderEngine2::SetResizerGUID ( GUID ResizerGuid ) {
    HRESULT _hr = raw_SetResizerGUID(ResizerGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IXml2Dex wrapper method implementations
//

inline HRESULT IXml2Dex::CreateGraphFromFile ( IUnknown * * ppGraph, IUnknown * pTimeline, _bstr_t Filename ) {
    HRESULT _hr = raw_CreateGraphFromFile(ppGraph, pTimeline, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::WriteGrfFile ( IUnknown * pGraph, _bstr_t Filename ) {
    HRESULT _hr = raw_WriteGrfFile(pGraph, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::WriteXMLFile ( IUnknown * pTimeline, _bstr_t Filename ) {
    HRESULT _hr = raw_WriteXMLFile(pTimeline, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::ReadXMLFile ( IUnknown * pTimeline, _bstr_t XMLName ) {
    HRESULT _hr = raw_ReadXMLFile(pTimeline, XMLName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::Delete ( IUnknown * pTimeline, double dStart, double dEnd ) {
    HRESULT _hr = raw_Delete(pTimeline, dStart, dEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::WriteXMLPart ( IUnknown * pTimeline, double dStart, double dEnd, _bstr_t Filename ) {
    HRESULT _hr = raw_WriteXMLPart(pTimeline, dStart, dEnd, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::PasteXMLFile ( IUnknown * pTimeline, double dStart, _bstr_t Filename ) {
    HRESULT _hr = raw_PasteXMLFile(pTimeline, dStart, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::CopyXML ( IUnknown * pTimeline, double dStart, double dEnd ) {
    HRESULT _hr = raw_CopyXML(pTimeline, dStart, dEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::PasteXML ( IUnknown * pTimeline, double dStart ) {
    HRESULT _hr = raw_PasteXML(pTimeline, dStart);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::ReadXML ( IUnknown * pTimeline, IUnknown * pxml ) {
    HRESULT _hr = raw_ReadXML(pTimeline, pxml);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IXml2Dex::WriteXML ( IUnknown * pTimeline, BSTR * pbstrXML ) {
    HRESULT _hr = raw_WriteXML(pTimeline, pbstrXML);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMediaSample wrapper method implementations
//

inline HRESULT IMediaSample::GetPointer ( unsigned char * * ppBuffer ) {
    HRESULT _hr = raw_GetPointer(ppBuffer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::GetTime ( __int64 * pTimeStart, __int64 * pTimeEnd ) {
    HRESULT _hr = raw_GetTime(pTimeStart, pTimeEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetTime ( __int64 * pTimeStart, __int64 * pTimeEnd ) {
    HRESULT _hr = raw_SetTime(pTimeStart, pTimeEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::IsSyncPoint ( ) {
    HRESULT _hr = raw_IsSyncPoint();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetSyncPoint ( long bIsSyncPoint ) {
    HRESULT _hr = raw_SetSyncPoint(bIsSyncPoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::IsPreroll ( ) {
    HRESULT _hr = raw_IsPreroll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetPreroll ( long bIsPreroll ) {
    HRESULT _hr = raw_SetPreroll(bIsPreroll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetActualDataLength ( long __MIDL__IMediaSample0000 ) {
    HRESULT _hr = raw_SetActualDataLength(__MIDL__IMediaSample0000);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::GetMediaType ( struct _AMMediaType * * ppMediaType ) {
    HRESULT _hr = raw_GetMediaType(ppMediaType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetMediaType ( struct _AMMediaType * pMediaType ) {
    HRESULT _hr = raw_SetMediaType(pMediaType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::IsDiscontinuity ( ) {
    HRESULT _hr = raw_IsDiscontinuity();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetDiscontinuity ( long bDiscontinuity ) {
    HRESULT _hr = raw_SetDiscontinuity(bDiscontinuity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::GetMediaTime ( __int64 * pTimeStart, __int64 * pTimeEnd ) {
    HRESULT _hr = raw_GetMediaTime(pTimeStart, pTimeEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaSample::SetMediaTime ( __int64 * pTimeStart, __int64 * pTimeEnd ) {
    HRESULT _hr = raw_SetMediaTime(pTimeStart, pTimeEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISampleGrabberCB wrapper method implementations
//

inline HRESULT ISampleGrabberCB::SampleCB ( double SampleTime, struct IMediaSample * pSample ) {
    HRESULT _hr = raw_SampleCB(SampleTime, pSample);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISampleGrabberCB::BufferCB ( double SampleTime, unsigned char * pBuffer, long BufferLen ) {
    HRESULT _hr = raw_BufferCB(SampleTime, pBuffer, BufferLen);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISampleGrabber wrapper method implementations
//

inline HRESULT ISampleGrabber::SetOneShot ( long OneShot ) {
    HRESULT _hr = raw_SetOneShot(OneShot);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISampleGrabber::SetMediaType ( struct _AMMediaType * pType ) {
    HRESULT _hr = raw_SetMediaType(pType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISampleGrabber::GetConnectedMediaType ( struct _AMMediaType * pType ) {
    HRESULT _hr = raw_GetConnectedMediaType(pType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISampleGrabber::SetBufferSamples ( long BufferThem ) {
    HRESULT _hr = raw_SetBufferSamples(BufferThem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISampleGrabber::GetCurrentBuffer ( long * pBufferSize, long * pBuffer ) {
    HRESULT _hr = raw_GetCurrentBuffer(pBufferSize, pBuffer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IMediaSamplePtr ISampleGrabber::GetCurrentSample ( ) {
    struct IMediaSample * _result = 0;
    HRESULT _hr = raw_GetCurrentSample(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMediaSamplePtr(_result, false);
}

inline HRESULT ISampleGrabber::SetCallback ( struct ISampleGrabberCB * pCallback, long WhichMethodToCallback ) {
    HRESULT _hr = raw_SetCallback(pCallback, WhichMethodToCallback);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMediaDet wrapper method implementations
//

inline IUnknownPtr IMediaDet::GetFilter ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get_Filter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

inline void IMediaDet::PutFilter ( IUnknown * pVal ) {
    HRESULT _hr = put_Filter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IMediaDet::GetOutputStreams ( ) {
    long _result = 0;
    HRESULT _hr = get_OutputStreams(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IMediaDet::GetCurrentStream ( ) {
    long _result = 0;
    HRESULT _hr = get_CurrentStream(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IMediaDet::PutCurrentStream ( long pVal ) {
    HRESULT _hr = put_CurrentStream(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline GUID IMediaDet::GetStreamType ( ) {
    GUID _result;
    HRESULT _hr = get_StreamType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IMediaDet::GetStreamTypeB ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StreamTypeB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline double IMediaDet::GetStreamLength ( ) {
    double _result = 0;
    HRESULT _hr = get_StreamLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t IMediaDet::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IMediaDet::PutFilename ( _bstr_t pVal ) {
    HRESULT _hr = put_Filename(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT IMediaDet::GetBitmapBits ( double streamTime, long * pBufferSize, unsigned char * pBuffer, long Width, long Height ) {
    HRESULT _hr = raw_GetBitmapBits(streamTime, pBufferSize, pBuffer, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IMediaDet::WriteBitmapBits ( double streamTime, long Width, long Height, _bstr_t Filename ) {
    HRESULT _hr = raw_WriteBitmapBits(streamTime, Width, Height, Filename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline struct _AMMediaType IMediaDet::GetStreamMediaType ( ) {
    struct _AMMediaType _result;
    HRESULT _hr = get_StreamMediaType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IMediaDet::GetSampleGrabber ( struct ISampleGrabber * * ppVal ) {
    HRESULT _hr = raw_GetSampleGrabber(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline double IMediaDet::GetFrameRate ( ) {
    double _result = 0;
    HRESULT _hr = get_FrameRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IMediaDet::EnterBitmapGrabMode ( double SeekTime ) {
    HRESULT _hr = raw_EnterBitmapGrabMode(SeekTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDXEffect wrapper method implementations
//

inline long IDXEffect::GetCapabilities ( ) {
    long _result = 0;
    HRESULT _hr = get_Capabilities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float IDXEffect::GetProgress ( ) {
    float _result = 0;
    HRESULT _hr = get_Progress(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDXEffect::PutProgress ( float pVal ) {
    HRESULT _hr = put_Progress(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float IDXEffect::GetStepResolution ( ) {
    float _result = 0;
    HRESULT _hr = get_StepResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline float IDXEffect::GetDuration ( ) {
    float _result = 0;
    HRESULT _hr = get_Duration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDXEffect::PutDuration ( float pVal ) {
    HRESULT _hr = put_Duration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IDxtCompositor wrapper method implementations
//

inline long IDxtCompositor::GetOffsetX ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutOffsetX ( long pVal ) {
    HRESULT _hr = put_OffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetOffsetY ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutOffsetY ( long pVal ) {
    HRESULT _hr = put_OffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetSrcOffsetX ( ) {
    long _result = 0;
    HRESULT _hr = get_SrcOffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutSrcOffsetX ( long pVal ) {
    HRESULT _hr = put_SrcOffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetSrcOffsetY ( ) {
    long _result = 0;
    HRESULT _hr = get_SrcOffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutSrcOffsetY ( long pVal ) {
    HRESULT _hr = put_SrcOffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetSrcWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_SrcWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutSrcWidth ( long pVal ) {
    HRESULT _hr = put_SrcWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtCompositor::GetSrcHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_SrcHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtCompositor::PutSrcHeight ( long pVal ) {
    HRESULT _hr = put_SrcHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IDxtAlphaSetter wrapper method implementations
//

inline long IDxtAlphaSetter::GetAlpha ( ) {
    long _result = 0;
    HRESULT _hr = get_Alpha(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtAlphaSetter::PutAlpha ( long pVal ) {
    HRESULT _hr = put_Alpha(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline double IDxtAlphaSetter::GetAlphaRamp ( ) {
    double _result = 0;
    HRESULT _hr = get_AlphaRamp(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtAlphaSetter::PutAlphaRamp ( double pVal ) {
    HRESULT _hr = put_AlphaRamp(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IDxtJpeg wrapper method implementations
//

inline long IDxtJpeg::GetMaskNum ( ) {
    long _result = 0;
    HRESULT _hr = get_MaskNum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutMaskNum ( long __MIDL__IDxtJpeg0000 ) {
    HRESULT _hr = put_MaskNum(__MIDL__IDxtJpeg0000);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t IDxtJpeg::GetMaskName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MaskName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void IDxtJpeg::PutMaskName ( _bstr_t pVal ) {
    HRESULT _hr = put_MaskName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline double IDxtJpeg::GetScaleX ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutScaleX ( double __MIDL__IDxtJpeg0002 ) {
    HRESULT _hr = put_ScaleX(__MIDL__IDxtJpeg0002);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline double IDxtJpeg::GetScaleY ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutScaleY ( double __MIDL__IDxtJpeg0004 ) {
    HRESULT _hr = put_ScaleY(__MIDL__IDxtJpeg0004);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetOffsetX ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutOffsetX ( long __MIDL__IDxtJpeg0006 ) {
    HRESULT _hr = put_OffsetX(__MIDL__IDxtJpeg0006);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetOffsetY ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutOffsetY ( long __MIDL__IDxtJpeg0008 ) {
    HRESULT _hr = put_OffsetY(__MIDL__IDxtJpeg0008);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetReplicateX ( ) {
    long _result = 0;
    HRESULT _hr = get_ReplicateX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutReplicateX ( long pVal ) {
    HRESULT _hr = put_ReplicateX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetReplicateY ( ) {
    long _result = 0;
    HRESULT _hr = get_ReplicateY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutReplicateY ( long pVal ) {
    HRESULT _hr = put_ReplicateY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetBorderColor ( ) {
    long _result = 0;
    HRESULT _hr = get_BorderColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutBorderColor ( long pVal ) {
    HRESULT _hr = put_BorderColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetBorderWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_BorderWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutBorderWidth ( long pVal ) {
    HRESULT _hr = put_BorderWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtJpeg::GetBorderSoftness ( ) {
    long _result = 0;
    HRESULT _hr = get_BorderSoftness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtJpeg::PutBorderSoftness ( long pVal ) {
    HRESULT _hr = put_BorderSoftness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT IDxtJpeg::ApplyChanges ( ) {
    HRESULT _hr = raw_ApplyChanges();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IDxtJpeg::LoadDefSettings ( ) {
    HRESULT _hr = raw_LoadDefSettings();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDxtKey wrapper method implementations
//

inline int IDxtKey::GetKeyType ( ) {
    int _result = 0;
    HRESULT _hr = get_KeyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutKeyType ( int __MIDL__IDxtKey0000 ) {
    HRESULT _hr = put_KeyType(__MIDL__IDxtKey0000);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline int IDxtKey::GetHue ( ) {
    int _result = 0;
    HRESULT _hr = get_Hue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutHue ( int __MIDL__IDxtKey0002 ) {
    HRESULT _hr = put_Hue(__MIDL__IDxtKey0002);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline int IDxtKey::GetLuminance ( ) {
    int _result = 0;
    HRESULT _hr = get_Luminance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutLuminance ( int __MIDL__IDxtKey0004 ) {
    HRESULT _hr = put_Luminance(__MIDL__IDxtKey0004);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline unsigned long IDxtKey::GetRGB ( ) {
    unsigned long _result = 0;
    HRESULT _hr = get_RGB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutRGB ( unsigned long __MIDL__IDxtKey0006 ) {
    HRESULT _hr = put_RGB(__MIDL__IDxtKey0006);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline int IDxtKey::GetSimilarity ( ) {
    int _result = 0;
    HRESULT _hr = get_Similarity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutSimilarity ( int __MIDL__IDxtKey0008 ) {
    HRESULT _hr = put_Similarity(__MIDL__IDxtKey0008);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long IDxtKey::GetInvert ( ) {
    long _result = 0;
    HRESULT _hr = get_Invert(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void IDxtKey::PutInvert ( long __MIDL__IDxtKey0010 ) {
    HRESULT _hr = put_Invert(__MIDL__IDxtKey0010);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAMTimeline wrapper method implementations
//

inline HRESULT IAMTimeline::CreateEmptyNode ( struct IAMTimelineObj * * ppObj, TIMELINE_MAJOR_TYPE Type ) {
    HRESULT _hr = raw_CreateEmptyNode(ppObj, Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::AddGroup ( struct IAMTimelineObj * pGroup ) {
    HRESULT _hr = raw_AddGroup(pGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::RemGroupFromList ( struct IAMTimelineObj * pGroup ) {
    HRESULT _hr = raw_RemGroupFromList(pGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetGroup ( struct IAMTimelineObj * * ppGroup, long WhichGroup ) {
    HRESULT _hr = raw_GetGroup(ppGroup, WhichGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetGroupCount ( long * pCount ) {
    HRESULT _hr = raw_GetGroupCount(pCount);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::ClearAllGroups ( ) {
    HRESULT _hr = raw_ClearAllGroups();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetInsertMode ( long * pMode ) {
    HRESULT _hr = raw_GetInsertMode(pMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetInsertMode ( long Mode ) {
    HRESULT _hr = raw_SetInsertMode(Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::EnableTransitions ( long fEnabled ) {
    HRESULT _hr = raw_EnableTransitions(fEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::TransitionsEnabled ( long * pfEnabled ) {
    HRESULT _hr = raw_TransitionsEnabled(pfEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::EnableEffects ( long fEnabled ) {
    HRESULT _hr = raw_EnableEffects(fEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::EffectsEnabled ( long * pfEnabled ) {
    HRESULT _hr = raw_EffectsEnabled(pfEnabled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetInterestRange ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetInterestRange(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDuration ( __int64 * pDuration ) {
    HRESULT _hr = raw_GetDuration(pDuration);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDuration2 ( double * pDuration ) {
    HRESULT _hr = raw_GetDuration2(pDuration);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetDefaultFPS ( double FPS ) {
    HRESULT _hr = raw_SetDefaultFPS(FPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDefaultFPS ( double * pFPS ) {
    HRESULT _hr = raw_GetDefaultFPS(pFPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::IsDirty ( long * pDirty ) {
    HRESULT _hr = raw_IsDirty(pDirty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDirtyRange ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_GetDirtyRange(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetCountOfType ( long Group, long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE majortype ) {
    HRESULT _hr = raw_GetCountOfType(Group, pVal, pValWithComps, majortype);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::ValidateSourceNames ( long ValidateFlags, struct IMediaLocator * pOverride, LONG_PTR NotifyEventHandle ) {
    HRESULT _hr = raw_ValidateSourceNames(ValidateFlags, pOverride, NotifyEventHandle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetDefaultTransition ( GUID * pGuid ) {
    HRESULT _hr = raw_SetDefaultTransition(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDefaultTransition ( GUID * pGuid ) {
    HRESULT _hr = raw_GetDefaultTransition(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetDefaultEffect ( GUID * pGuid ) {
    HRESULT _hr = raw_SetDefaultEffect(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::GetDefaultEffect ( GUID * pGuid ) {
    HRESULT _hr = raw_GetDefaultEffect(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimeline::SetDefaultTransitionB ( _bstr_t pGuid ) {
    HRESULT _hr = raw_SetDefaultTransitionB(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimeline::GetDefaultTransitionB ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDefaultTransitionB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IAMTimeline::SetDefaultEffectB ( _bstr_t pGuid ) {
    HRESULT _hr = raw_SetDefaultEffectB(pGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimeline::GetDefaultEffectB ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetDefaultEffectB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAMTimelineObj wrapper method implementations
//

inline HRESULT IAMTimelineObj::GetStartStop ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_GetStartStop(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetStartStop2 ( double * pStart, double * pStop ) {
    HRESULT _hr = raw_GetStartStop2(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::FixTimes ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_FixTimes(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::FixTimes2 ( double * pStart, double * pStop ) {
    HRESULT _hr = raw_FixTimes2(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetStartStop ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetStartStop(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetStartStop2 ( double Start, double Stop ) {
    HRESULT _hr = raw_SetStartStop2(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IPropertySetterPtr IAMTimelineObj::GetPropertySetter ( ) {
    struct IPropertySetter * _result = 0;
    HRESULT _hr = raw_GetPropertySetter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPropertySetterPtr(_result, false);
}

inline HRESULT IAMTimelineObj::SetPropertySetter ( struct IPropertySetter * newVal ) {
    HRESULT _hr = raw_SetPropertySetter(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline IUnknownPtr IAMTimelineObj::GetSubObject ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw_GetSubObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

inline HRESULT IAMTimelineObj::SetSubObject ( IUnknown * newVal ) {
    HRESULT _hr = raw_SetSubObject(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetSubObjectGUID ( GUID newVal ) {
    HRESULT _hr = raw_SetSubObjectGUID(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetSubObjectGUIDB ( _bstr_t newVal ) {
    HRESULT _hr = raw_SetSubObjectGUIDB(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetSubObjectGUID ( GUID * pVal ) {
    HRESULT _hr = raw_GetSubObjectGUID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimelineObj::GetSubObjectGUIDB ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetSubObjectGUIDB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IAMTimelineObj::GetSubObjectLoaded ( long * pVal ) {
    HRESULT _hr = raw_GetSubObjectLoaded(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetTimelineType ( TIMELINE_MAJOR_TYPE * pVal ) {
    HRESULT _hr = raw_GetTimelineType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetTimelineType ( TIMELINE_MAJOR_TYPE newVal ) {
    HRESULT _hr = raw_SetTimelineType(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetUserID ( long * pVal ) {
    HRESULT _hr = raw_GetUserID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetUserID ( long newVal ) {
    HRESULT _hr = raw_SetUserID(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetGenID ( long * pVal ) {
    HRESULT _hr = raw_GetGenID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimelineObj::GetUserName ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetUserName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IAMTimelineObj::SetUserName ( _bstr_t newVal ) {
    HRESULT _hr = raw_SetUserName(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetUserData ( unsigned char * pData, long * pSize ) {
    HRESULT _hr = raw_GetUserData(pData, pSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetUserData ( unsigned char * pData, long Size ) {
    HRESULT _hr = raw_SetUserData(pData, Size);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetMuted ( long * pVal ) {
    HRESULT _hr = raw_GetMuted(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetMuted ( long newVal ) {
    HRESULT _hr = raw_SetMuted(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetLocked ( long * pVal ) {
    HRESULT _hr = raw_GetLocked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetLocked ( long newVal ) {
    HRESULT _hr = raw_SetLocked(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetDirtyRange ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_GetDirtyRange(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetDirtyRange2 ( double * pStart, double * pStop ) {
    HRESULT _hr = raw_GetDirtyRange2(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetDirtyRange ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetDirtyRange(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::SetDirtyRange2 ( double Start, double Stop ) {
    HRESULT _hr = raw_SetDirtyRange2(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::ClearDirty ( ) {
    HRESULT _hr = raw_ClearDirty();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::Remove ( ) {
    HRESULT _hr = raw_Remove();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetTimelineNoRef ( struct IAMTimeline * * ppResult ) {
    HRESULT _hr = raw_GetTimelineNoRef(ppResult);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetGroupIBelongTo ( struct IAMTimelineGroup * * ppGroup ) {
    HRESULT _hr = raw_GetGroupIBelongTo(ppGroup);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineObj::GetEmbedDepth ( long * pVal ) {
    HRESULT _hr = raw_GetEmbedDepth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineSrc wrapper method implementations
//

inline HRESULT IAMTimelineSrc::GetMediaTimes ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_GetMediaTimes(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetMediaTimes2 ( double * pStart, double * pStop ) {
    HRESULT _hr = raw_GetMediaTimes2(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::ModifyStopTime ( __int64 Stop ) {
    HRESULT _hr = raw_ModifyStopTime(Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::ModifyStopTime2 ( double Stop ) {
    HRESULT _hr = raw_ModifyStopTime2(Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::FixMediaTimes ( __int64 * pStart, __int64 * pStop ) {
    HRESULT _hr = raw_FixMediaTimes(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::FixMediaTimes2 ( double * pStart, double * pStop ) {
    HRESULT _hr = raw_FixMediaTimes2(pStart, pStop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetMediaTimes ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetMediaTimes(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetMediaTimes2 ( double Start, double Stop ) {
    HRESULT _hr = raw_SetMediaTimes2(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetMediaLength ( __int64 Length ) {
    HRESULT _hr = raw_SetMediaLength(Length);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetMediaLength2 ( double Length ) {
    HRESULT _hr = raw_SetMediaLength2(Length);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetMediaLength ( __int64 * pLength ) {
    HRESULT _hr = raw_GetMediaLength(pLength);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetMediaLength2 ( double * pLength ) {
    HRESULT _hr = raw_GetMediaLength2(pLength);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimelineSrc::GetMediaName ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetMediaName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IAMTimelineSrc::SetMediaName ( _bstr_t newVal ) {
    HRESULT _hr = raw_SetMediaName(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SpliceWithNext ( struct IAMTimelineObj * pNext ) {
    HRESULT _hr = raw_SpliceWithNext(pNext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetStreamNumber ( long * pVal ) {
    HRESULT _hr = raw_GetStreamNumber(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetStreamNumber ( long Val ) {
    HRESULT _hr = raw_SetStreamNumber(Val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::IsNormalRate ( long * pVal ) {
    HRESULT _hr = raw_IsNormalRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetDefaultFPS ( double * pFPS ) {
    HRESULT _hr = raw_GetDefaultFPS(pFPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetDefaultFPS ( double FPS ) {
    HRESULT _hr = raw_SetDefaultFPS(FPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::GetStretchMode ( int * pnStretchMode ) {
    HRESULT _hr = raw_GetStretchMode(pnStretchMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineSrc::SetStretchMode ( int nStretchMode ) {
    HRESULT _hr = raw_SetStretchMode(nStretchMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineGroup wrapper method implementations
//

inline HRESULT IAMTimelineGroup::SetTimeline ( struct IAMTimeline * pTimeline ) {
    HRESULT _hr = raw_SetTimeline(pTimeline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetTimeline ( struct IAMTimeline * * ppTimeline ) {
    HRESULT _hr = raw_GetTimeline(ppTimeline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetPriority ( long * pPriority ) {
    HRESULT _hr = raw_GetPriority(pPriority);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetMediaType ( struct _AMMediaType * __MIDL__IAMTimelineGroup0000 ) {
    HRESULT _hr = raw_GetMediaType(__MIDL__IAMTimelineGroup0000);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetMediaType ( struct _AMMediaType * __MIDL__IAMTimelineGroup0001 ) {
    HRESULT _hr = raw_SetMediaType(__MIDL__IAMTimelineGroup0001);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetOutputFPS ( double FPS ) {
    HRESULT _hr = raw_SetOutputFPS(FPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetOutputFPS ( double * pFPS ) {
    HRESULT _hr = raw_GetOutputFPS(pFPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetGroupName ( _bstr_t pGroupName ) {
    HRESULT _hr = raw_SetGroupName(pGroupName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IAMTimelineGroup::GetGroupName ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetGroupName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IAMTimelineGroup::SetPreviewMode ( long fPreview ) {
    HRESULT _hr = raw_SetPreviewMode(fPreview);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetPreviewMode ( long * pfPreview ) {
    HRESULT _hr = raw_GetPreviewMode(pfPreview);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetMediaTypeForVB ( long Val ) {
    HRESULT _hr = raw_SetMediaTypeForVB(Val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetOutputBuffering ( int * pnBuffer ) {
    HRESULT _hr = raw_GetOutputBuffering(pnBuffer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetOutputBuffering ( int nBuffer ) {
    HRESULT _hr = raw_SetOutputBuffering(nBuffer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetSmartRecompressFormat ( long * pFormat ) {
    HRESULT _hr = raw_SetSmartRecompressFormat(pFormat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::GetSmartRecompressFormat ( long * * ppFormat ) {
    HRESULT _hr = raw_GetSmartRecompressFormat(ppFormat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::IsSmartRecompressFormatSet ( long * pVal ) {
    HRESULT _hr = raw_IsSmartRecompressFormatSet(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::IsRecompressFormatDirty ( long * pVal ) {
    HRESULT _hr = raw_IsRecompressFormatDirty(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::ClearRecompressFormatDirty ( ) {
    HRESULT _hr = raw_ClearRecompressFormatDirty();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineGroup::SetRecompFormatFromSource ( struct IAMTimelineSrc * pSource ) {
    HRESULT _hr = raw_SetRecompFormatFromSource(pSource);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineEffectable wrapper method implementations
//

inline HRESULT IAMTimelineEffectable::EffectInsBefore ( struct IAMTimelineObj * pFX, long priority ) {
    HRESULT _hr = raw_EffectInsBefore(pFX, priority);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineEffectable::EffectSwapPriorities ( long PriorityA, long PriorityB ) {
    HRESULT _hr = raw_EffectSwapPriorities(PriorityA, PriorityB);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineEffectable::EffectGetCount ( long * pCount ) {
    HRESULT _hr = raw_EffectGetCount(pCount);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineEffectable::GetEffect ( struct IAMTimelineObj * * ppFx, long Which ) {
    HRESULT _hr = raw_GetEffect(ppFx, Which);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineTrack wrapper method implementations
//

inline HRESULT IAMTimelineTrack::SrcAdd ( struct IAMTimelineObj * pSource ) {
    HRESULT _hr = raw_SrcAdd(pSource);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetNextSrc ( struct IAMTimelineObj * * ppSrc, __int64 * pInOut ) {
    HRESULT _hr = raw_GetNextSrc(ppSrc, pInOut);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetNextSrc2 ( struct IAMTimelineObj * * ppSrc, double * pInOut ) {
    HRESULT _hr = raw_GetNextSrc2(ppSrc, pInOut);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::MoveEverythingBy ( __int64 Start, __int64 MoveBy ) {
    HRESULT _hr = raw_MoveEverythingBy(Start, MoveBy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::MoveEverythingBy2 ( double Start, double MoveBy ) {
    HRESULT _hr = raw_MoveEverythingBy2(Start, MoveBy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetSourcesCount ( long * pVal ) {
    HRESULT _hr = raw_GetSourcesCount(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::AreYouBlank ( long * pVal ) {
    HRESULT _hr = raw_AreYouBlank(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetSrcAtTime ( struct IAMTimelineObj * * ppSrc, __int64 Time, long SearchDirection ) {
    HRESULT _hr = raw_GetSrcAtTime(ppSrc, Time, SearchDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetSrcAtTime2 ( struct IAMTimelineObj * * ppSrc, double Time, long SearchDirection ) {
    HRESULT _hr = raw_GetSrcAtTime2(ppSrc, Time, SearchDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::InsertSpace ( __int64 rtStart, __int64 rtEnd ) {
    HRESULT _hr = raw_InsertSpace(rtStart, rtEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::InsertSpace2 ( double rtStart, double rtEnd ) {
    HRESULT _hr = raw_InsertSpace2(rtStart, rtEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::ZeroBetween ( __int64 rtStart, __int64 rtEnd ) {
    HRESULT _hr = raw_ZeroBetween(rtStart, rtEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::ZeroBetween2 ( double rtStart, double rtEnd ) {
    HRESULT _hr = raw_ZeroBetween2(rtStart, rtEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTrack::GetNextSrcEx ( struct IAMTimelineObj * pLast, struct IAMTimelineObj * * ppNext ) {
    HRESULT _hr = raw_GetNextSrcEx(pLast, ppNext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineTransable wrapper method implementations
//

inline HRESULT IAMTimelineTransable::TransAdd ( struct IAMTimelineObj * pTrans ) {
    HRESULT _hr = raw_TransAdd(pTrans);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTransable::TransGetCount ( long * pCount ) {
    HRESULT _hr = raw_TransGetCount(pCount);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTransable::GetNextTrans ( struct IAMTimelineObj * * ppTrans, __int64 * pInOut ) {
    HRESULT _hr = raw_GetNextTrans(ppTrans, pInOut);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTransable::GetNextTrans2 ( struct IAMTimelineObj * * ppTrans, double * pInOut ) {
    HRESULT _hr = raw_GetNextTrans2(ppTrans, pInOut);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTransable::GetTransAtTime ( struct IAMTimelineObj * * ppObj, __int64 Time, long SearchDirection ) {
    HRESULT _hr = raw_GetTransAtTime(ppObj, Time, SearchDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineTransable::GetTransAtTime2 ( struct IAMTimelineObj * * ppObj, double Time, long SearchDirection ) {
    HRESULT _hr = raw_GetTransAtTime2(ppObj, Time, SearchDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAMTimelineComp wrapper method implementations
//

inline HRESULT IAMTimelineComp::VTrackInsBefore ( struct IAMTimelineObj * pVirtualTrack, long priority ) {
    HRESULT _hr = raw_VTrackInsBefore(pVirtualTrack, priority);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::VTrackSwapPriorities ( long VirtualTrackA, long VirtualTrackB ) {
    HRESULT _hr = raw_VTrackSwapPriorities(VirtualTrackA, VirtualTrackB);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::VTrackGetCount ( long * pVal ) {
    HRESULT _hr = raw_VTrackGetCount(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::GetVTrack ( struct IAMTimelineObj * * ppVirtualTrack, long Which ) {
    HRESULT _hr = raw_GetVTrack(ppVirtualTrack, Which);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::GetCountOfType ( long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE majortype ) {
    HRESULT _hr = raw_GetCountOfType(pVal, pValWithComps, majortype);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::GetRecursiveLayerOfType ( struct IAMTimelineObj * * ppVirtualTrack, long WhichLayer, TIMELINE_MAJOR_TYPE Type ) {
    HRESULT _hr = raw_GetRecursiveLayerOfType(ppVirtualTrack, WhichLayer, Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::GetRecursiveLayerOfTypeI ( struct IAMTimelineObj * * ppVirtualTrack, long * pWhichLayer, TIMELINE_MAJOR_TYPE Type ) {
    HRESULT _hr = raw_GetRecursiveLayerOfTypeI(ppVirtualTrack, pWhichLayer, Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAMTimelineComp::GetNextVTrack ( struct IAMTimelineObj * pVirtualTrack, struct IAMTimelineObj * * ppNextVirtualTrack ) {
    HRESULT _hr = raw_GetNextVTrack(pVirtualTrack, ppNextVirtualTrack);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IRenderEngine wrapper method implementations
//

inline HRESULT IRenderEngine::SetTimelineObject ( struct IAMTimeline * pTimeline ) {
    HRESULT _hr = raw_SetTimelineObject(pTimeline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::GetTimelineObject ( struct IAMTimeline * * ppTimeline ) {
    HRESULT _hr = raw_GetTimelineObject(ppTimeline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::GetFilterGraph ( struct IGraphBuilder * * ppFG ) {
    HRESULT _hr = raw_GetFilterGraph(ppFG);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetFilterGraph ( struct IGraphBuilder * pFG ) {
    HRESULT _hr = raw_SetFilterGraph(pFG);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetInterestRange ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetInterestRange(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetInterestRange2 ( double Start, double Stop ) {
    HRESULT _hr = raw_SetInterestRange2(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetRenderRange ( __int64 Start, __int64 Stop ) {
    HRESULT _hr = raw_SetRenderRange(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetRenderRange2 ( double Start, double Stop ) {
    HRESULT _hr = raw_SetRenderRange2(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::GetGroupOutputPin ( long Group, struct IPin * * ppRenderPin ) {
    HRESULT _hr = raw_GetGroupOutputPin(Group, ppRenderPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::ScrapIt ( ) {
    HRESULT _hr = raw_ScrapIt();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::RenderOutputPins ( ) {
    HRESULT _hr = raw_RenderOutputPins();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _bstr_t IRenderEngine::GetVendorString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetVendorString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline HRESULT IRenderEngine::ConnectFrontEnd ( ) {
    HRESULT _hr = raw_ConnectFrontEnd();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetSourceConnectCallback ( struct IGrfCache * pCallback ) {
    HRESULT _hr = raw_SetSourceConnectCallback(pCallback);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetDynamicReconnectLevel ( long Level ) {
    HRESULT _hr = raw_SetDynamicReconnectLevel(Level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::DoSmartRecompression ( ) {
    HRESULT _hr = raw_DoSmartRecompression();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::UseInSmartRecompressionGraph ( ) {
    HRESULT _hr = raw_UseInSmartRecompressionGraph();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::SetSourceNameValidation ( _bstr_t FilterString, struct IMediaLocator * pOverride, long Flags ) {
    HRESULT _hr = raw_SetSourceNameValidation(FilterString, pOverride, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::Commit ( ) {
    HRESULT _hr = raw_Commit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::Decommit ( ) {
    HRESULT _hr = raw_Decommit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IRenderEngine::GetCaps ( long Index, long * pReturn ) {
    HRESULT _hr = raw_GetCaps(Index, pReturn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFilterGraph wrapper method implementations
//

inline HRESULT IFilterGraph::AddFilter ( struct IBaseFilter * pFilter, LPWSTR pName ) {
    HRESULT _hr = raw_AddFilter(pFilter, pName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::RemoveFilter ( struct IBaseFilter * pFilter ) {
    HRESULT _hr = raw_RemoveFilter(pFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::EnumFilters ( struct IEnumFilters * * ppEnum ) {
    HRESULT _hr = raw_EnumFilters(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::FindFilterByName ( LPWSTR pName, struct IBaseFilter * * ppFilter ) {
    HRESULT _hr = raw_FindFilterByName(pName, ppFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::ConnectDirect ( struct IPin * ppinOut, struct IPin * ppinIn, struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_ConnectDirect(ppinOut, ppinIn, pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::Reconnect ( struct IPin * pPin ) {
    HRESULT _hr = raw_Reconnect(pPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::Disconnect ( struct IPin * pPin ) {
    HRESULT _hr = raw_Disconnect(pPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IFilterGraph::SetDefaultSyncSource ( ) {
    HRESULT _hr = raw_SetDefaultSyncSource();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IGraphBuilder wrapper method implementations
//

inline HRESULT IGraphBuilder::Connect ( struct IPin * ppinOut, struct IPin * ppinIn ) {
    HRESULT _hr = raw_Connect(ppinOut, ppinIn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::Render ( struct IPin * ppinOut ) {
    HRESULT _hr = raw_Render(ppinOut);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::RenderFile ( LPWSTR lpcwstrFile, LPWSTR lpcwstrPlayList ) {
    HRESULT _hr = raw_RenderFile(lpcwstrFile, lpcwstrPlayList);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::AddSourceFilter ( LPWSTR lpcwstrFileName, LPWSTR lpcwstrFilterName, struct IBaseFilter * * ppFilter ) {
    HRESULT _hr = raw_AddSourceFilter(lpcwstrFileName, lpcwstrFilterName, ppFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::SetLogFile ( ULONG_PTR hFile ) {
    HRESULT _hr = raw_SetLogFile(hFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::Abort ( ) {
    HRESULT _hr = raw_Abort();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGraphBuilder::ShouldOperationContinue ( ) {
    HRESULT _hr = raw_ShouldOperationContinue();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IBaseFilter wrapper method implementations
//

inline HRESULT IBaseFilter::EnumPins ( struct IEnumPins * * ppEnum ) {
    HRESULT _hr = raw_EnumPins(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IBaseFilter::FindPin ( LPWSTR Id, struct IPin * * ppPin ) {
    HRESULT _hr = raw_FindPin(Id, ppPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IBaseFilter::QueryFilterInfo ( struct _FilterInfo * pInfo ) {
    HRESULT _hr = raw_QueryFilterInfo(pInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IBaseFilter::JoinFilterGraph ( struct IFilterGraph * pGraph, LPWSTR pName ) {
    HRESULT _hr = raw_JoinFilterGraph(pGraph, pName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IBaseFilter::QueryVendorInfo ( LPWSTR * pVendorInfo ) {
    HRESULT _hr = raw_QueryVendorInfo(pVendorInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPin wrapper method implementations
//

inline HRESULT IPin::Connect ( struct IPin * pReceivePin, struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_Connect(pReceivePin, pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::ReceiveConnection ( struct IPin * pConnector, struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_ReceiveConnection(pConnector, pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::Disconnect ( ) {
    HRESULT _hr = raw_Disconnect();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::ConnectedTo ( struct IPin * * pPin ) {
    HRESULT _hr = raw_ConnectedTo(pPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::ConnectionMediaType ( struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_ConnectionMediaType(pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::QueryPinInfo ( struct _PinInfo * pInfo ) {
    HRESULT _hr = raw_QueryPinInfo(pInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::QueryDirection ( enum _PinDirection * pPinDir ) {
    HRESULT _hr = raw_QueryDirection(pPinDir);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::QueryId ( LPWSTR * Id ) {
    HRESULT _hr = raw_QueryId(Id);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::QueryAccept ( struct _AMMediaType * pmt ) {
    HRESULT _hr = raw_QueryAccept(pmt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::EnumMediaTypes ( struct IEnumMediaTypes * * ppEnum ) {
    HRESULT _hr = raw_EnumMediaTypes(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::QueryInternalConnections ( struct IPin * * apPin, unsigned long * nPin ) {
    HRESULT _hr = raw_QueryInternalConnections(apPin, nPin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::EndOfStream ( ) {
    HRESULT _hr = raw_EndOfStream();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::BeginFlush ( ) {
    HRESULT _hr = raw_BeginFlush();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::EndFlush ( ) {
    HRESULT _hr = raw_EndFlush();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IPin::NewSegment ( __int64 tStart, __int64 tStop, double dRate ) {
    HRESULT _hr = raw_NewSegment(tStart, tStop, dRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEnumPins wrapper method implementations
//

inline HRESULT IEnumPins::Next ( unsigned long cPins, struct IPin * * ppPins, unsigned long * pcFetched ) {
    HRESULT _hr = raw_Next(cPins, ppPins, pcFetched);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumPins::Skip ( unsigned long cPins ) {
    HRESULT _hr = raw_Skip(cPins);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumPins::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumPins::Clone ( struct IEnumPins * * ppEnum ) {
    HRESULT _hr = raw_Clone(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEnumFilters wrapper method implementations
//

inline HRESULT IEnumFilters::Next ( unsigned long cFilters, struct IBaseFilter * * ppFilter, unsigned long * pcFetched ) {
    HRESULT _hr = raw_Next(cFilters, ppFilter, pcFetched);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumFilters::Skip ( unsigned long cFilters ) {
    HRESULT _hr = raw_Skip(cFilters);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumFilters::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IEnumFilters::Clone ( struct IEnumFilters * * ppEnum ) {
    HRESULT _hr = raw_Clone(ppEnum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IGrfCache wrapper method implementations
//

inline HRESULT IGrfCache::AddFilter ( struct IGrfCache * ChainedCache, __int64 Id, struct IBaseFilter * pFilter, LPWSTR pName ) {
    HRESULT _hr = raw_AddFilter(ChainedCache, Id, pFilter, pName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGrfCache::ConnectPins ( struct IGrfCache * ChainedCache, __int64 PinID1, struct IPin * pPin1, __int64 PinID2, struct IPin * pPin2 ) {
    HRESULT _hr = raw_ConnectPins(ChainedCache, PinID1, pPin1, PinID2, pPin2);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGrfCache::SetGraph ( struct IGraphBuilder * pGraph ) {
    HRESULT _hr = raw_SetGraph(pGraph);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IGrfCache::DoConnectionsNow ( ) {
    HRESULT _hr = raw_DoConnectionsNow();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFindCompressorCB wrapper method implementations
//

inline HRESULT IFindCompressorCB::GetCompressor ( struct _AMMediaType * pType, struct _AMMediaType * pCompType, struct IBaseFilter * * ppFilter ) {
    HRESULT _hr = raw_GetCompressor(pType, pCompType, ppFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISmartRenderEngine wrapper method implementations
//

inline HRESULT ISmartRenderEngine::SetGroupCompressor ( long Group, struct IBaseFilter * pCompressor ) {
    HRESULT _hr = raw_SetGroupCompressor(Group, pCompressor);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISmartRenderEngine::GetGroupCompressor ( long Group, struct IBaseFilter * * pCompressor ) {
    HRESULT _hr = raw_GetGroupCompressor(Group, pCompressor);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT ISmartRenderEngine::SetFindCompressorCB ( struct IFindCompressorCB * pCallback ) {
    HRESULT _hr = raw_SetFindCompressorCB(pCallback);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}
